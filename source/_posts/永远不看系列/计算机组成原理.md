---
title: 计算机组成原理
date: 2024-03-02 18:20:00
categories: 永远不看系列
permalink: computer-organization.html
mathjax: true
---

计算机基础不牢。

<!--more-->

## 应试技巧（注意：这里的知识是未经验证的，不一定正确）

### 计算机体系概论

> “存储程序”特点？

早期计算机通过硬件开关或打孔纸带输入程序，程序和数据是分离的。老冯提出了把毒和鸡汤存储在一起的思想：把程序和数据存在一起，存在存储器里。

> 计算机的五个子系统？

我们为什么要造计算机，要算个什么东西。所以输入、输出、算术逻辑运算肯定是有的。怎么算，你在草稿纸上算题，得有你这个人控制，得有中间结果。所以控制和存储是有的。

> 主机？

主机就是你引脚直接装在主板上的东西，粗略地理解为 CPU + 内存。显示器和鼠标键盘属于输入输出系统，用线连在机箱外面。剩下三个系统就是主机：控制单元和算术逻辑单元 ALU 合称中央处理单元 CPU；存储系统包括硬盘、内存、cache、寄存器，这四个是体积越小、容量越小、价格越贵。但是：硬盘不属于主存，不算在主机里面，它和输入输出系统合称外部设备，即“用户与计算机通信的界面”。

> ALU？

即算术逻辑单元 Arithmetic and Logic Unit

> 指令和数据？

指令和数据都是二进制的，在形式上无法区分，由控制器判断谁是指令，谁是数据。判断的依据是：当前处于哪个访问阶段，是处于取指周期还是执行周期。当程序被启动执行后，其指令和数据从外存被装进内存。

> 取指执行过程？

你上司给你发了一张纸，这张纸就是内存。纸上写了一些暗号：午时三刻，当街问斩。这个暗号就是指令，问斩是操作码，当街是地址码。你收到这张纸后，把指令从纸上取到你脑子缓冲区里，你脑子缓冲区就是指令寄存器，你至少得反应一会，这个反应的过程就是译码，

> K？

按具体上下文，单独一个 K 可指 KB，即 2 的 10 次方个字节（Byte）

> 汇编语言？

汇编语言与具体的机器结构（指令集架构）有关，其源程序不能直接在机器上执行，还得过一道汇编器。

> 机器语言？

计算机硬件可以直接执行的是机器语言程序，一系列 0 和 1。不是硬件描述语言，硬件描述语言是写电路的，用这种语言描述电路结构。汇编语言还要过一遍汇编器。

> 机器字长？

机器字长是二进制的位数，是 ALU 和通用寄存器的宽度。指令寄存器和浮点寄存器的宽度可能与其不等。

> 面向量纲/单位计算？

CPI 的单位是：个(时钟周期)每个(指令)

时钟周期的量纲是：时间。这一个时钟周期有它的具体时间长度。

主频的量纲是：频率，时间的倒数。一秒钟被分割成了有多少个时钟周期。

MIPS 的单位是：(百万)个(指令)每个(秒)

这里的 M 是 10 的 6 次方，主频里的 G 是 10 的 9 次方，往上指数+3 为 T P E B

做计算题，先搞明白指令总数、时钟周期总数。指令总数乘上 CPI 等于时钟周期总数。时间就是时钟周期总数乘上每个时钟周期所占的时间长度。

在纸上画图：一个秒被切割成了一系列时钟周期，每个时钟周期执行一条指令。直接设未知数，列方程。

### 运算方法和运算器

幺二八六四 三二幺六 八四二幺 五二五幺二五 零六二五

在发草稿纸之后，直接把 0 到 F 全写下来（想当年笔者可以把元素周期表画下来（除了镧系和锕系），包括一直到气奥的各个元素名、绝大部分元素符号以及常见的相对原子质量，还有 38324 14122 横批 4546 之类的。但是现在不行了。还有 2^31 - 1 = 2147483647，这是四字节 int 类型的最大值，这个数字最早在《植物大战僵尸》的修改器里见到，如果你无尽模式或者自选关过了这一波，它的程序会崩掉）

> 原码反码补码移码？

正整数的原码反码补码都是它的二进制按照某一个特定的位数表示，前面补零。

负整数的原码，最高位为符号位 1，后面为它的二进制形式按照某一个特定的位数表示，前面补零。

负整数的反码，为原码除符号位的所有位按位取反后的结果。

负整数的补码，为其反码 + 1，按位截断。

移码 = 【真值 + （最高位所代表的 2 的次方值 - 1）】的无符号整数表示

如八位下 5 的移码是 `5 + 2^(8-1)` = `5 + 127` = `4 + 128` = `1000 0100`

> 八位下，零的表示形式？

正零的原码：00000000

负零的原码：10000000

正零的反码：00000000

负零的反码：11111111

正零/负零的补码：00000000

> -26？

26 = 16 + 8 + 2

= 10000 + 1000 + 10

= 00011010

-26 = 10011010（原）= 11100101（反）= 11100110（补）= E6H

> BCD 码？

用二进制编码的十进制数(Binary-Coded Decimal)。对于 8421 码，是把十进制数的每一个位转换成一个四位的二进制数。

如(1145)\_10 = (0001 0001 0100 0101)\_BCD

> 进制转换？

分向十进制转、从十进制向外转、二八十六互转。

向十进制转：各个位的十进制值乘上以原进制为底、该位与小数点的相对位置为指数的幂，再相加。其中小数点左边一位的相对位置为零，小数点右边一位的相对位置为负一，以此类推。

从十进制向外转：除 k 取余法+乘 k 取整法。整数部分用短除法列竖式，用新进制的基数去除，除到商为零为止，之前的所有余数从下向上排列为新数的整数部分；小数部分乘上新进制的基数，取积的整数部分为新数的小数部分，积的小数部分继续与基数乘，直到积的小数部分为零或者出现循环节为止。

对于一个 1000 以内的十进制数转成二进制，除 k 取余法还是太教科书了，你可以直接把它拆分成 2 的幂相加，因为加减法不容易出错。

二八十六互转：四位二进制位与一位十六进制位在[0,16)这个整数范围内一一对应。小数点前后的部分直接按片段替换。三位二进制位与一位八进制位在[0,8)这个整数范围内一一对应。小数点前后的部分直接按片段替换。八与十六互转时，以二作为桥梁。

> 浮点数的编码方式？

对于 32 位浮点数 float，即单精度浮点数，最高位为符号位，后 8 位为阶码，再后 23 位为尾数。

阶码决定范围，尾数决定精度。

浮点数转真值：把 1.与 23 位尾数缝合起来，转成十进制；把阶码作为移码求真值，作为 2 的指数；两者相乘，带上符号位。

普通数转浮点数：把**绝对值**先转成二进制，小数点挪到第一个 1 的后面，为符号(1.xxx)乘 2^指数；符号放最高位；指数转为移码放后 8 位；小数点后的部分取“0 舍 1 入”的 23 位。

（意思就是：1.7 和 -1.7 只差一个符号位）

对于 64 位双精度浮点数 double：阶码变成了 11 位

> float 的五种形式？

32 位二进制浮点数，她的位数是有限的，不可能双射无限多（阿列夫一）的（实）数。

- 阶码全零，尾数全零：正/负机器零
- 阶码全零，尾数不全零：非规格化数
- 阶码全 1，尾数全零：正/负无穷大
- 阶码全 1，尾数不全零：不是数（NaN）

她的阶码有 8 位，当不是全零或全一时，我们称她为规格化的。把阶码移码的身份转回正经数后，指数范围为[-126,+127]，不考虑尾数，对应真值约 2^(-126) 到 2^127，又约 10^(-38) 到 10^38。

浮点数原码运算时，判定结果为规格化数的条件是：尾数的最高位为 1

> 奇偶校验？

看 1 的个数

> 串行运算器？

从低位到高位逐位运算

> 加法器采用先行进位的目的？

加速传递进位信号（没明白）

> 采用双符号位的定点补码运算器，何时结果溢出？

双符号位不同（没明白）

### 存储系统

> 存取周期？

存储器进行连续读和写操作所允许的最短时间间隔（没明白）

> 存储器采用分级存储的目的？

钱、容量、速度三者不能兼得。

> 寻址范围？

1. 内存能存储多少位二进制数
2. 多少位二进制数作为一个地址
3. 两者相除，结果无单位

> 已被淘汰的存储器？

磁芯存储器

> 主存？

主存由 RAM(Random Access Memory，随机存取存储器)和 ROM(只读存储器，Read-Only Memory)组成。同一个存储器里，每个存储单元宽度相同

> PROM? EPROM?

前者是可编程(P)的 ROM，后者是可擦除的 PROM。

PROM 不一定可被改写。EPROM 可被改写多次，但不能作 RAM

U 盘、TF 卡属于闪存，闪存属于 EPROM

> SRAM? DRAM?

一静一动，一快一慢。

前者用于 CPU 缓存。后者用于主存、需要定时刷新、行列地址引脚复用(RAS 行地址选通信号引脚、CAS 列地址选通信号引脚)

> 磁盘和磁带？

存取时间与存取单元的物理位置有关。磁带串行存取，磁盘部分串行存取。

> 存储芯片的地址线数据线？

存储容量=地址数\*位宽

数据线或引脚数目=位宽

SRAM 地址线或引脚数目=log_2(地址数)，与位宽无关

DRAM 地址线或引脚数目=0.5log_2(地址数)，与位宽无关

> MAR? MDR?

存储器地址寄存器、存储器数据寄存器

MAR 宽度=log_2(地址数)

MDR 宽度至少为每次读写操作最多存取的位数

> 某一 RAM 芯片其容量是 512\*8 位，除电源和接地端外该芯片引线的最少数目是多少？

数据线 8+地址线 log2(512)+片选线 1+读写线 1=19

> 双端口存储器？

左右端口地址码相同时，发生读写冲突

> 多体交叉存储器解决的问题？

提高主存的数据传输率

> cache 的功能全部由谁实现？

硬件

> 与 cache 命中率无关的是？

主存的存取时间

> cache 的地址映射？

主存 到 cache

多对一：直接映射

多对多：全相联映射

组相联映射：

1. 把主存和 cache 都分为若干组
2. 对于主存的某一组，其块数=cache 组数。其所有块分配给 cache 的各个组，对于每一块，其被分到的 cache 组固定、不一定分配到 cache 组的哪一行

> 某计算机的 Cache 共有 16 行，采用 2 路-组相联映射方式(即每组包括 2 行)。存储器按字节编址，每个主存块大小为 32 字节。主存 135 号单元所在主存块应装入的 cache 组号？

简记： cache 组号 = 主存单元号 // 主存块字节数 % cache 组数

cache 分 8 组，每组两行。则主存分若干组，每组 8 块。

cache 组号 = 主存块号 % 主存每组块数

= 单元号 // 字节数 % 主存每组块数

= 135 // 32 % 8

= 4

简记是什么意思？因为笔者写出来的东西都是笔者不会的，至少是在写出来之前的那一段时间是不会的，如果笔者在写出来之后会了，那么就不会使用“简记”这两个字了。简记的意思是：我对这个知识点没搞明白，也不想搞明白，所以按感性提了一个公式出来，这个公式根本记不住，没有内化到自身。“简记”在笔者的潜意识里有两层麻痹自我的意思：简的意思是：我没搞懂；记的意思是：我记不住。

> cache？

cache 是易失型存储器。当程序具有较好的访问局部性时，能更好地发挥 cache 的作用。

> 闪速存储器？

闪速存储器是一种高密度，非易失的读/写半导体存储器

> 下列 cache 替换算法中，速度最快的是？命中率最高的是？LFU LRU 随机替换

随机替换 LRU

### 指令系统

> 程序控制类指令的功能？

改变程序执行的顺序

> RISC？

指令长度固定，减少指令数，增加寄存器数

> 一地址格式的指令？

一地址格式的算术运算指令，另一个操作数隐含在累加器里

一地址格式的指令，可能有一个操作数，也可能有两个操作数

> 怎么区分寄存器中的值是地址还是数据？

指令操作码或寻址方式位

> 一条指令中，操作数的寻址方式？

看指令地址码是什么：

- 操作数所在的存储单元：寄存器间接寻址
- 操作数所在的存储单元地址：直接寻址
- 操作数所在的寄存器编号：寄存器直接寻址
- 操作数本身：立即寻址

## CPU 性能指标

$T$ 时钟周期：计算机中最短的时间。类比：一面有秒针的钟，最短时间为 1 秒。类比：普朗克时间。类比：“一周”的“最短时间”为“天”

$f$ 主频/时钟频率：一秒钟之内，包含多少个时钟周期。对于一个可以精确到 0.01 秒的秒表，其“主频”为 100Hz

$N_\mathrm{C}$ 时钟周期数：天数、Num of Cycle

$I_\mathrm{N}$ 指令数：任务数、Instruction Num

$\mathrm{CPI}$ (Cycle Per Instruction)：每条指令平均时钟周期数。完成每个任务的平均天数。你的时钟周期为“天”，有 100 个任务(指令)要完成，完成它们共花了 200 天。你的 CPI 为 2 天/任务

$\mathrm{CPI} \times I_\mathrm{N} = N_\mathrm{C}$

$\mathrm{MIPS}$：百万条指令数/秒

$\mathrm{FLOPS}$：浮点操作数/秒

$t_\mathrm{CPU}$ 执行时间：执行一段程序(若干条指令)所花费时间。

$$
\begin{aligned}
= & 指令数 \times \mathrm{CPI} \times  时钟周期\\
= & 任务数 \times 每个任务所花天数 \times 一天有多少秒\\
= & 执行该程序所经过时钟周期数 \times 时钟周期\\
= & 花了多少天 \times 一天有多少秒\\
\end{aligned}
$$

## 使用一个字节记录整数

计算机存储的数据由一系列 `0` 和 `1` 表示，每个 `0` 或 `1` 称为一个二进制位，八个二进制位组成一个字节。一个字节的范围：

`0000 0000 - 1111 1111`

使用一个字节，可以表示多少种状态？对每一位来说，只有两种可能的状态：`0` 或 `1`。一共有八个不同的位，所以可以表示 $2^8=256$ 种状态。

把 `0000 0000 - 1111 1111` 转换为十进制数是 $0$ 到 $255$，有 $256$ 个数。它当然可以通过进制转换，表示 $0$ 到 $255$ 的整数（也可以叫“无符号整数”）。

我们想表示负数，可以这样规定：只把后面七个二进制位转换成十进制，而用第一个二进制位表示符号（其中 `0` 表示正号，`1` 表示负号），即：

- `0 0000000 - 0 1111111` 表示 $+0$ 到 $+127$
- `1 0000000 - 1 1111111` 表示 $-0$ 到 $-127$

这被称为**原码**表示法。

我们想用原码计算 $4 - 7$，即 $4 + (-7)$：

- `0000 0100` $-$ `0000 0111` $=$ `1111 1101`，可以看到，结果不是 $-3$
- `0000 0100` $+$ `1000 0111` $=$ `1000 1011`，可以看到，结果不是 $-3$

因为有符号位干扰，但我们想**让符号位也参与计算**的同时，加和减的结果相同且满足定义。还是用符号位表示正负，后七个位表示绝对值。

有一台钟（12 个数字的）慢了 3 小时，此时 `+3` 和 `-9` 是等价的。它的“循环周期”是 `12`

用后七个位表示绝对值，“循环周期”就是 `128`。此时，`-7` 和 `+121` 等价

采用**补码**表示法：

- `0 0000000 - 0 1111111` 表示 $0$ 到 $127$
- `1 0000000 - 1 1111111` 表示 $-128$ 到 $-1$

此时计算 $4 - 7$：

- `0000 0100` $-$ `0000 0111` $=$ `1111 1101`
- `0000 0100` $+$ `1111 1001` $=$ `1111 1101`

可以看到：

- 正数的补码与原码相同
- 负数的补码：
  - 总是以“全 $1$”来表示 $-1$，然后依次往前推
  - 原码按位取反（除了符号位）后再加一
  - 原码从右往左第一个 $1$ 之前的位（除了符号位）按位取反

## 逐位进位加法器的实现

1. 用两个非门、两个与门、一个或门实现异或门

```py
def xor_gate(a: bool, b: bool):
    return (a and not b) or (not a and b)


truth = (True, False)

for a in truth:
    for b in truth:
        print(f"{int(a)} xor {int(b)} = {int(xor_gate(a,b))}")
```

2. 用一个异或门、一个与门实现半加器

两个一位的二进制数相加，和一位，进一位：

- 0 + 0 和 0 进 0
- 0 + 1 和 1 进 0
- 1 + 0 和 1 进 0
- 1 + 1 和 0 进 1

和的位由异或得来，进的位由与得来：

```py
def half_adder(a: bool, b: bool):
    sum_ = xor_gate(a, b)
    carry = a and b
    return sum_, carry


truth = (True, False)

for a in truth:
    for b in truth:
        s, c = half_adder(a, b)
        print(f"{int(a)} + {int(b)} 进 {int(c)} 和 {int(s)}")
```

3. 用两个半加器、一个或门实现全加器

两个本位的数相加后，再加上低位进的位。和一位，进一位：

```py
def full_adder(a: bool, b: bool, carry_in: bool):
    s1, c1 = half_adder(a, b)
    s2, c2 = half_adder(s1, carry_in)
    carry_out = c1 or c2
    return s2, carry_out

truth = (True, False)

for a in truth:
    for b in truth:
        for c in truth:
            s, c_out = full_adder(a, b, c)
            print(f"{int(a)} + {int(b)} + {int(c)} 进 {int(c_out)} 和 {int(s)}")
```

4. 四个全加器串联实现四位加法器

```py
from itertools import product

truth = (True, False)
numbers = tuple(product(truth, repeat=4))


def adder(a: tuple[bool, bool, bool, bool], b: tuple[bool, bool, bool, bool]):
    s1, c1 = full_adder(a[-1], b[-1], False)
    s2, c2 = full_adder(a[-2], b[-2], c1)
    s3, c3 = full_adder(a[-3], b[-3], c2)
    s4, c4 = full_adder(a[-4], b[-4], c3)
    return c4, s4, s3, s2, s1


def to_number(a: tuple[bool, ...]):
    binary_string = "".join(str(int(elem)) for elem in a)
    decimal_number = int(binary_string, 2)
    return decimal_number


for a in numbers:
    for b in numbers:
        result = adder(a, b)
        print(f"{to_number(a)} + {to_number(b)} = {to_number(result)}")
```

## 普通十进制数转单精度浮点数

交叉引用[运算方法和运算器](#运算方法和运算器)

- 在 IEEE 754 标准下

单精度浮点数，即 32 位二进制浮点数，包含：

一位符号位 + 八位指数位 + 二十三位尾数位

下面的例子中，没有带尾缀的都是十进制，带尾缀 $\mathrm{B}$ 的是二进制

### 例一

以 $0.1$ 为例：

1. 把十进制转换为二进制
   $0.1 = 0.0\dot{0}01\dot{1}... \mathrm{B}$
2. 用以 $2$ 为基数的科学计数法表示，并保证【尾数的小数点前是 $1 \mathrm{B}$】
   $= 1.\dot{1}00\dot{1}...\mathrm{B} \times (2^{-4})$
   可以看到指数是 $-4$
3. 计算指数位（又叫阶码），用指数加上偏移量 $(2^{e-1}-1)$

   这里 $e$ 等于【用于表示指数位的位数】 $8$，所以偏移量为 $127$

   则阶码为 $-4 + 127 = 123$

   阶码的二进制为 `0111 1011`，注意 _阶码为无符号整数_

4. 取科学计数法的【小数点后二十三位】作为【尾数位】，因为是无限的，所以要舍去一部分

   它的前二十位是：`1001 1001 1001 1001 1001`

   二十一至二十八位是：`1001 1001`

   所以二十一至二十三位，要么取 `100`，要么取 `101`。

   第二十四位是 `1`，0 舍 1 入，所以取 `101`

5. 把符号位连同阶码、尾数位缝合起来

   `0 | 0111 1011 | 1001 1001 1001 1001 1001 101`

### 例二

以 $-12 = 1.5 \times (2^{3})$ 为例：

1. 把十进制转换为二进制

   $12  = 1100 \mathrm{B}$

2. 用以 $2$ 为基数的科学计数法表示，并保证【尾数的小数点前是 $1$】

   $= 1.1\mathrm{B} \times (2^3)$

   可以看到指数是 $3$

3. 计算指数位（又叫阶码），用指数加上偏移量 $(2^{e-1}-1)$

   这里 $e$ 等于【用于表示指数位的位数】 $8$，所以偏移量为 $127$

   则阶码为 $3 + 127 = 130$

   阶码的二进制为 `1000 0010`，注意 _阶码为无符号整数_

4. 取科学计数法的【小数点后二十三位】作为【尾数位】，因为是有限的，所以后面直接补零

   小数点后二十三位是：`1000 0000 0000 0000 000`

5. 把符号位连同阶码、尾数位缝合起来

   `1 | 1000 0010 | 1000 0000 0000 0000 000`

### 如何验证

- [在线转换](https://baseconvert.com/ieee-754-floating-point)
- [Wikipedia](https://en.wikipedia.org/wiki/IEEE_754) | [维基百科](https://zh.wikipedia.org/wiki/IEEE_754)
- 获取国际标准文件。IEEE 754 标准是电气与电子工程师协会（Institute of Electrical and Electronics Engineers）制定的关于浮点数表示和运算的标准。最新标准是 [IEEE 754-2019](https://standards.ieee.org/ieee/754/6210/)，对应国际标准 [ISO/IEC 60559:2020](https://www.iso.org/cms/%20render/live/en/sites/isoorg/contents/data/standard/08/09/80985.html)，预计下一次在 2028 年修订。http://snti.ru/ 这个网站分享了各种国际标准文件的磁力链接，但是可以免费下载的不全，IEC 的只有 61xxx。据说可以给站长发邮件要 `popov_al@perm.ru`，每个文件一刀乐。在 ISO 官网上下载需要 187 瑞士法郎，合 1000 多人民币。

用 GDB：

```c
#include <stdio.h>

int main()
{
    float num = 1.7;
    printf("");
}
```

在第六行打上断点，VSCode 开调试，在调试控制台里：

```sh
-exec x/4tb &num
```

- `-exec` 执行命令
- `x` 查看内存
- `4` 输出 4 个单元
  - 不写默认为 `1`
- `t` 以二进制形式输出
  - `x` 十六进制
- `b` 以【一个字节】为一个单元
  - `h` 两个字节
  - `w` 四个字节
  - `g` 八个字节
- `&`取变量地址

输出结果：

`0x61fe1c: 10011010 10011001 11011001 00111111`

从右往左排列后：

`00111111 11011001 10011001 10011010`

`0 01111111 10110011001100110011010`

才是`float 1.7`的二进制表示。

还可以直接用

```sh
-exec x/tw &num
```

输出四个字节，结果：

`0x61fe1c: 00111111110110011001100110011010`

